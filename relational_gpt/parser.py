"""
DSL Parser for RelationalGPT

This module provides functionality to parse LLM-generated DSL code and convert it
into executable Python code for the RelationalGPT framework.
"""

import re
from typing import Dict, List, Optional, Tuple, Union, Any

class DSLParser:
    """
    Parser for RelationalGPT DSL generated by LLMs.
    """
    
    def __init__(self):
        """Initialize the DSL parser."""
        # Patterns for matching DSL components
        self.relation_pattern = r'([A-Za-z_][A-Za-z0-9_]*)\s*=\s*\[(.*?)\]'
        self.constraint_pattern = r'ensure\s*\(\s*["\']([^"\']+)["\'],\s*(.+)\s*\)'
        self.workflow_pattern = r'([A-Za-z_][A-Za-z0-9_]*)\s*=\s*Workflow\s*\(\s*["\']([^"\']+)["\']\s*\)'
        self.page_pattern = r'\.add_page\s*\(\s*Page\s*\(\s*["\']([^"\']+)["\'](?:,\s*route\s*=\s*["\']([^"\']+)["\'])?\s*\)'
    
    def parse_llm_output(self, llm_output: str) -> str:
        """
        Parse LLM-generated output and convert it to valid Python code.
        
        Args:
            llm_output: Raw text output from the LLM.
            
        Returns:
            Valid Python code that can be executed by the RelationalGPT framework.
        """
        # Extract imports and add necessary imports
        python_code = self._add_imports(llm_output)
        
        # Extract relations
        relations = self._extract_relations(llm_output)
        for relation_name, relation_code in relations:
            python_code += f"\n\n{relation_name} = {relation_code}"
        
        # Extract workflows
        workflows = self._extract_workflows(llm_output)
        for workflow_name, workflow_code in workflows:
            python_code += f"\n\n{workflow_code}"
        
        # Extract constraints
        constraints = self._extract_constraints(llm_output)
        if constraints:
            python_code += "\n\n\ndef run_constraints():\n"
            for description, condition in constraints:
                python_code += f"    ensure(\n        \"{description}\",\n        {condition}\n    )\n"
        
        return python_code
    
    def _add_imports(self, llm_output: str) -> str:
        """
        Add necessary imports to the generated code.
        
        Args:
            llm_output: Raw text output from the LLM.
            
        Returns:
            Python code with imports.
        """
        imports = [
            "from relational.dsl import restrict, join, project, extend, summarize, ensure",
            "from workflow.dsl import Workflow, Page, Section, Flow, Validation"
        ]
        
        # Check if additional imports are needed based on LLM output
        if "price_to_price_band" in llm_output:
            imports.append("from tests.test_conditions import price_to_price_band")
        
        return "\n".join(imports)
    
    def _extract_relations(self, llm_output: str) -> List[Tuple[str, str]]:
        """
        Extract relation definitions from LLM output.
        
        Args:
            llm_output: Raw text output from the LLM.
            
        Returns:
            A list of tuples (relation_name, relation_code).
        """
        # Find relation definitions (lists of dictionaries)
        matches = []
        
        # First, find all candidates using regex
        candidates = re.finditer(self.relation_pattern, llm_output, re.DOTALL)
        
        for match in candidates:
            relation_name = match.group(1)
            relation_content = match.group(2)
            
            # Check if this is actually a relation (list of dictionaries)
            if "{" in relation_content and "}" in relation_content:
                matches.append((relation_name, f"[{relation_content}]"))
        
        return matches
    
    def _extract_constraints(self, llm_output: str) -> List[Tuple[str, str]]:
        """
        Extract constraint definitions from LLM output.
        
        Args:
            llm_output: Raw text output from the LLM.
            
        Returns:
            A list of tuples (description, condition).
        """
        matches = []
        
        # Find all ensure() calls
        candidates = re.finditer(self.constraint_pattern, llm_output, re.DOTALL)
        
        for match in candidates:
            description = match.group(1)
            condition = match.group(2)
            matches.append((description, condition))
        
        return matches
    
    def _extract_workflows(self, llm_output: str) -> List[Tuple[str, str]]:
        """
        Extract workflow definitions from LLM output.
        
        Args:
            llm_output: Raw text output from the LLM.
            
        Returns:
            A list of tuples (workflow_name, workflow_code).
        """
        matches = []
        
        # Extract workflow instantiations
        workflow_matches = re.finditer(self.workflow_pattern, llm_output, re.DOTALL)
        
        for match in workflow_matches:
            workflow_name = match.group(1)
            workflow_title = match.group(2)
            
            # Initialize workflow variable with proper Python syntax
            workflow_init = f"{workflow_name} = Workflow(\"{workflow_title}\")"
            
            # Create a list to collect all add_page calls
            pages_code = []
            
            # Find all add_page() calls for this workflow
            workflow_start_pos = match.end()
            
            # Look for add_page calls
            page_matches = re.finditer(self.page_pattern, llm_output[workflow_start_pos:], re.DOTALL)
            
            for page_match in page_matches:
                page_name = page_match.group(1)
                page_route = page_match.group(2) if page_match.group(2) else None
                
                if page_route:
                    page_code = f"Page(\"{page_name}\", route=\"{page_route}\")"
                else:
                    page_code = f"Page(\"{page_name}\")"
                
                # Start building the page code
                full_page_code = f"{workflow_name}.add_page(\n    {page_code}"
                
                # Extract the entire page definition including chained method calls
                page_end_pos = workflow_start_pos + page_match.end()
                remainder = llm_output[page_end_pos:]
                
                # Find the closing parenthesis for this add_page call
                paren_count = 1
                for i, char in enumerate(remainder):
                    if char == '(':
                        paren_count += 1
                    elif char == ')':
                        paren_count -= 1
                        if paren_count == 0:
                            page_content = remainder[:i]
                            full_page_code += page_content + ")"
                            break
                
                # Add this page to our collection
                pages_code.append(full_page_code)
            
            # Build the complete workflow code
            workflow_code = workflow_init + "\n" + "\n".join(pages_code)
            
            matches.append((workflow_name, workflow_code))
        
        return matches
    
    def format_as_python_file(self, parsed_code: str) -> str:
        """
        Format the parsed code as a complete Python file.
        
        Args:
            parsed_code: Parsed Python code.
            
        Returns:
            A formatted Python file with proper imports and structure.
        """
        return f"""# Generated RelationalGPT DSL Code
{parsed_code}

if __name__ == "__main__":
    # For testing, print all defined relations
    for var_name, var_value in locals().items():
        if isinstance(var_value, list) and all(isinstance(item, dict) for item in var_value if var_value):
            print(f"Relation: {{var_name}} with {{len(var_value)}} rows")
    
    # Run constraints if defined
    if 'run_constraints' in locals():
        print("\\nRunning constraints:")
        run_constraints()
"""
